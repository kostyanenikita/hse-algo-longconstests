#include <iostream>

struct node {
    int value;
    node* next;

    explicit node()
            : next(nullptr)
    { }

    explicit node(int newValue)
            : value(newValue)
            , next(nullptr)
    { }
};

class ForwardList {
public:
    ForwardList()
            : _begin(nullptr)
    { }

    ~ForwardList() {
        node* currentNode = _begin;
        while (currentNode) {
            node* next = currentNode->next;
            delete currentNode;
            currentNode = next;
        }
    }

    node* begin() const {
        return _begin;
    }

    void push(int x) {
        node* newNode = new node(x);
        if (_begin) {
            newNode->next = _begin;
        }
        _begin = newNode;
    }

    void reverse() {
        node* currentNode = _begin;
        node* previousNode = nullptr;
        while (currentNode) {
            node* next = currentNode->next;
            currentNode->next = previousNode;
            previousNode = currentNode;
            currentNode = next;
        }
        _begin = previousNode;
    }

    ForwardList& operator=(ForwardList const& other) {
        _begin = other.begin();
        return *this;
    }

    ForwardList& operator=(node* const& other) {
        _begin = other;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& out, ForwardList& forwardList);

private:
    node* _begin;
};

std::ostream& operator<<(std::ostream& out, ForwardList& forwardList) {
    node* current = forwardList.begin();
    while (current) {
        out << current->value << ' ';
        current = current->next;
    }
    return out;
}

std::pair<node*, node*> Merge(node* firstNode, int firstSize, node* secondNode, int secondSize) {
    node* newBegin = nullptr;
    node* newEnd = nullptr;

    while (firstSize || secondSize) {
        if (!secondSize || (firstSize && firstNode->value < secondNode->value)) {
            if (newEnd) {
                newEnd->next = firstNode;
            }
            newEnd = firstNode;
            firstNode = firstNode->next;
            --firstSize;
        } else {
            if (newEnd) {
                newEnd->next = secondNode;
            }
            newEnd = secondNode;
            secondNode = secondNode->next;
            --secondSize;
        }

        if (!newBegin) {
            newBegin = newEnd;
        }
    }

    newEnd->next = nullptr;

    return std::make_pair(newBegin, newEnd);
}

std::pair<node*, node*> MergeSort(node* currentBegin, int currentSize) {
    if (currentSize == 1) {
        return std::make_pair(currentBegin, currentBegin);
    }

    node* firstBegin = currentBegin;
    node* firstEnd = nullptr;

    node* secondBegin = currentBegin;

    for (int i = 0; i != currentSize / 2; ++i) {
        secondBegin = secondBegin->next;
    }

    std::pair<node*, node*> result;

    result = MergeSort(firstBegin, currentSize / 2);
    firstBegin = result.first, firstEnd = result.second;

    result = MergeSort(secondBegin, currentSize - currentSize / 2);
    secondBegin = result.first;

    firstEnd->next = secondBegin;

    return Merge(firstBegin, currentSize / 2, secondBegin, currentSize - currentSize / 2);
}

int main() {
    std::ios_base::sync_with_stdio(0);

    int n;
    std::cin >> n;

    ForwardList forwardList;

    for (int i = 0; i != n; ++i) {
        int x;
        std::cin >> x;
        forwardList.push(x);
    }

    forwardList.reverse();

    forwardList = MergeSort(forwardList.begin(), n).first;

    std::cout << forwardList << '\n';

    return 0;
}
