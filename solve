#include <iostream>

struct node {
    int value;
    node* next;

    explicit node()
            : value(0)
            , next(nullptr)
    { }

    explicit node(int newValue)
            : value(newValue)
            , next(nullptr)
    { }
};

class ForwardList {
public:
    ForwardList()
            : _begin(nullptr)
    { }

    ~ForwardList() {
        node* removableNode = _begin;
        while (removableNode) {
            node* nextNode = removableNode->next;
            delete removableNode;
            removableNode = nextNode;
        }
    }

    node* begin() const {
        return _begin;
    }

    void push(int x) {
        node* newNode = new node(x);
        if (_begin) {
            newNode->next = _begin;
        }
        _begin = newNode;
    }

    void reverse() {
        node* currentNode = _begin;
        node* previousNode = nullptr;
        while (currentNode) {
            node* nextNode = currentNode->next;
            currentNode->next = previousNode;
            previousNode = currentNode;
            currentNode = nextNode;
        }
        _begin = previousNode;
    }

    ForwardList& operator=(ForwardList const& other) {
        _begin = other.begin();
        return *this;
    }

    ForwardList& operator=(node* const& other) {
        _begin = other;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& out, ForwardList& forwardList);

private:
    node* _begin;
};

std::ostream& operator<<(std::ostream& out, ForwardList& forwardList) {
    node* currentNode = forwardList.begin();
    while (currentNode) {
        out << currentNode->value << ' ';
        currentNode = currentNode->next;
    }
    return out;
}

node* Merge(node* firstNode, node* secondNode) {
    node* newBegin = nullptr;
    node* newEnd = nullptr;

    while (firstNode || secondNode) {
        if (!secondNode || (firstNode && firstNode->value < secondNode->value)) {
            if (newEnd) {
                newEnd->next = firstNode;
            } else {
                newBegin = firstNode;
            }
            newEnd = firstNode;
            firstNode = firstNode->next;
        } else {
            if (newEnd) {
                newEnd->next = secondNode;
            } else {
                newBegin = secondNode;
            }
            newEnd = secondNode;
            secondNode = secondNode->next;
        }
    }

    newEnd->next = nullptr;

    return newBegin;
}

node* MergeSort(node* currentBegin, int currentSize) {
    if (currentSize == 1) {
        currentBegin->next = nullptr;
        return currentBegin;
    }

    node* firstBegin = currentBegin;
    node* secondBegin = currentBegin;

    for (int i = 0; i != currentSize / 2; ++i) {
        secondBegin = secondBegin->next;
    }

    firstBegin = MergeSort(firstBegin, currentSize / 2);
    secondBegin = MergeSort(secondBegin, currentSize - currentSize / 2);

    return Merge(firstBegin, secondBegin);
}

int main() {
    std::ios_base::sync_with_stdio(false);

    int elementsNumber;
    std::cin >> elementsNumber;

    ForwardList forwardList;

    for (int i = 0; i != elementsNumber; ++i) {
        int x;
        std::cin >> x;
        forwardList.push(x);
    }

    forwardList.reverse();
    forwardList = MergeSort(forwardList.begin(), elementsNumber);

    std::cout << forwardList << '\n';

    return 0;
}
